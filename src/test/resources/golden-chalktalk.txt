-- Test: parses single argument on same line
-- Input:
Result: x
-- EndInput:
-- Output:
Result:
. x
-- EndOutput:


-- Test: parses single argument indented
-- Input:
Result:
. x
-- EndInput:
-- Output:
Result:
. x
-- EndOutput:


-- Test: parses multiple arguments single line
-- Input:
Result: a, b, c
-- EndInput:
-- Output:
Result:
. a
. b
. c
-- EndOutput:


-- Test: parses multiple arguments indented
-- Input:
Result:
. a
. b
. c
-- EndInput:
-- Output:
Result:
. a
. b
. c
-- EndOutput:


-- Test: parses multiple arguments mixed indented
-- Input:
Result: a, b
. c
. d, e
. f
-- EndInput:
-- Output:
Result:
. a
. b
. c
. d
. e
. f
-- EndOutput:


-- Test: parses text identifiers
-- Input:
Result: x
-- EndInput:
-- Output:
Result:
. x
-- EndOutput:


-- Test: parses operator identifiers
-- Input:
Result: *
-- EndInput:
-- Output:
Result:
. *
-- EndOutput:


-- Test: parses single var abstractions
-- Input:
Result: f(x)
-- EndInput:
-- Output:
Result:
. f(x)
-- EndOutput:


-- Test: parses multi var abstractions
-- Input:
Result: f(x, y, z)
-- EndInput:
-- Output:
Result:
. f(x, y, z)
-- EndOutput:


-- Test: parses enclosed plain abstractions
-- Input:
Result:
. for: {f}
  then: x
-- EndInput:
-- Output(Phase1):
Result:
. for:
  . {f}
  then:
  . x
-- EndOutput(Phase1):
-- Output(Phase2):
Result:
. for: {f}
  then:
  . x
-- EndOutput(Phase2):


-- Test: parses enclosed regular abstractions
-- Input:
Result:
. for: {f(x)}
  then: x
-- EndInput:
-- Output(Phase1):
Result:
. for:
  . {f(x)}
  then:
  . x
-- EndOutput(Phase1):
-- Output(Phase2):
Result:
. for: {f(x)}
  then:
  . x
-- EndOutput(Phase2):


-- Test: parses enclosed abstractions with sub params
-- Input:
Result:
. for: {a_i}
  then: x
-- EndInput:
-- Output(Phase1):
Result:
. for:
  . {a_i}
  then:
  . x
-- EndOutput(Phase1):
-- Output(Phase2):
Result:
. for: {a_i}
  then:
  . x
-- EndOutput(Phase2):


-- Test: parses names with ...
-- Input:
Result: abc...
-- EndInput:
-- Output:
Result:
. abc...
-- EndOutput:


-- Test: parses nested names with ...
-- Input:
Result: f(abc...)
-- EndInput:
-- Output:
Result:
. f(abc...)
-- EndOutput:


-- Test: parses abstractions with one sub param
-- Input:
Result:
. for: a_n
  then: b
-- EndInput:
-- Output(Phase1):
Result:
. for:
  . a_n
  then:
  . b
-- EndOutput(Phase1):
-- Output(Phase2):
Result:
. for: a_n
  then:
  . b
-- EndOutput(Phase2):


-- Test: parses abstractions with multiple sub params
-- Input:
Result:
. for: a_{x, y, z}
  then: b
-- EndInput:
-- Output(Phase1):
Result:
. for:
  . a_{x, y, z}
  then:
  . b
-- EndOutput(Phase1):
-- Output(Phase2):
Result:
. for: a_{x, y, z}
  then:
  . b
-- EndOutput(Phase2):


-- Test: parses abstractions with one sub param and multiple params
-- Input:
Result:
. for: a_n(x, y)
  then: b
-- EndInput:
-- Output(Phase1):
Result:
. for:
  . a_n(x, y)
  then:
  . b
-- EndOutput(Phase1):
-- Output(Phase2):
Result:
. for: a_n(x, y)
  then:
  . b
-- EndOutput(Phase2):


-- Test: parses abstractions with multiple sub params and multiple params
-- Input:
Result:
. for: a_{n, m}(x, y)
  then: b
-- EndInput:
-- Output(Phase1):
Result:
. for:
  . a_{n, m}(x, y)
  then:
  . b
-- EndOutput(Phase1):
-- Output(Phase2):
Result:
. for: a_{n, m}(x, y)
  then:
  . b
-- EndOutput(Phase2):


-- Test: parses abstractions with empty sub params and empty params
-- Input:
Result:
. for: a_{}()
  then: b
-- EndInput:
-- Output(Phase1):
Result:
. for:
  . a_{}()
  then:
  . b
-- EndOutput(Phase1):
-- Output(Phase2):
Result:
. for: a_{}()
  then:
  . b
-- EndOutput(Phase2):


-- Test: parses abstractions with empty sub params and non-empty params
-- Input:
Result:
. for: a_{}(x, y)
  then: b
-- EndInput:
-- Output(Phase1):
Result:
. for:
  . a_{}(x, y)
  then:
  . b
-- EndOutput(Phase1):
-- Output(Phase2):
Result:
. for: a_{}(x, y)
  then:
  . b
-- EndOutput(Phase2):


-- Test: parses abstractions with non-empty sub params and empty params
-- Input:
Result:
. for: a_{n, m}()
  then: b
-- EndInput:
-- Output(Phase1):
Result:
. for:
  . a_{n, m}()
  then:
  . b
-- EndOutput(Phase1):
-- Output(Phase2):
Result:
. for: a_{n, m}()
  then:
  . b
-- EndOutput(Phase2):


-- Test: handles a single classification in metadata
-- Input:
Result:
. "something"
Metadata:
. classification:
  . "a"
-- EndInput:
-- Output(Phase1):
Result:
. "something"
Metadata:
. classification:
  . "a"
-- EndOutput(Phase1):
-- Output(Phase2):
Result:
. "something"
Metadata:
. classification: "a"
-- EndOutput(Phase2):


-- Test: handles multiple classifications in metadata
-- Input:
Result:
. "something"
Metadata:
. classification:
  . "a"
  . "b"
  . "c"
-- EndInput:
-- Output:
Result:
. "something"
Metadata:
. classification:
  . "a"
  . "b"
  . "c"
-- EndOutput:


-- Test: handles a single tag in metadata
-- Input:
Result:
. "something"
Metadata:
. tag:
  . "a"
-- EndInput:
-- Output(Phase1):
Result:
. "something"
Metadata:
. tag:
  . "a"
-- EndOutput(Phase1):
-- Output(Phase2):
Result:
. "something"
Metadata:
. tag: "a"
-- EndOutput(Phase2):


-- Test: handles multiple tags in metadata
-- Input:
Result:
. "something"
Metadata:
. tag:
  . "a"
  . "b"
  . "c"
-- EndInput:
-- Output:
Result:
. "something"
Metadata:
. tag:
  . "a"
  . "b"
  . "c"
-- EndOutput:


-- Test: handles sources with a single author
-- Input:
[id]
Source:
. name: "some name"
. author: "author1"
-- EndInput:
-- Output(Phase1):
[id]
Source:
. name:
  . "some name"
. author:
  . "author1"
-- EndOutput(Phase1):
-- Output(Phase2):
[id]
Source:
. name: "some name"
. author: "author1"
-- EndOutput(Phase2):


-- Test: handles sources with multiple authors
-- Input:
[id]
Source:
. name: "some name"
. author:
  . "author1"
  . "author2"
  . "author3"
-- EndInput:
-- Output(Phase1):
[id]
Source:
. name:
  . "some name"
. author:
  . "author1"
  . "author2"
  . "author3"
-- EndOutput(Phase1):
-- Output(Phase2):
[id]
Source:
. name: "some name"
. author:
  . "author1"
  . "author2"
  . "author3"
-- EndOutput(Phase2):
